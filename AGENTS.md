## Architecture

Layered architecture with strict dependency direction: **UI → Presentation → Data → Domain**.

| Layer | Path | Responsibility |
|-------|------|----------------|
| Core | `lib/core/` | DI (GetIt), routing (go_router), base classes |
| Domain | `lib/domain/` | Entities, mappers — no framework imports |
| Data | `lib/data/` | Repositories, services, sync logic |
| Presentation | `lib/presentation/` | BLoCs only (events, states) |
| UI | `lib/ui/` | Screens and widgets — no business logic |

Do not break this layering. UI must never import from `data/` or `domain/` directly; it goes through BLoCs. BLoCs must never import Flutter widgets.

## State Management — BLoC

- Use `flutter_bloc`. Every feature gets its own BLoC with separate `*_event.dart` and `*_state.dart` files.
- Events extend `BaseEvent` (from `core/bloc/base/`), states extend `BaseState`. Both use `Equatable` with explicit `props`.
- States must implement `copyWith`.
- BLoCs are registered in `lib/core/di/modules/blocs_module.dart` using GetIt (`factory` for transient, `lazySingleton` for shared).
- Never use `setState`, `ChangeNotifier`, or any other state management approach.

## Dependency Injection

- Use `get_it` exclusively. All registrations live in `lib/core/di/modules/`.
- Three modules: `ServicesModule`, `RepositoriesModule`, `BlocsModule`.
- Repositories follow the pattern: abstract interface + `*Impl` class. Register the impl, type-hint the abstract.

## Rust Integration

- Native Rust code lives in `rust/src/`. The bridge is generated by flutter_rust_bridge into `lib/src/rust/`.
- Dart wrappers for Rust APIs live in `lib/data/services/rust_nostr_bridge.dart`.
- Never edit files inside `lib/src/rust/` — they are auto-generated. Edit `rust/src/api/` and regenerate.
- Rust modules: `crypto`, `database` (LMDB), `relay`, `events`, `nip17`, `nip19`.
- After modifying Rust code, regenerate the bridge with `flutter_rust_bridge_codegen generate`.

## Routing

- Use `go_router`. Route definitions live in `lib/core/router/`.
- Bottom navigation uses `StatefulShellRoute` with tabs: Feed, DM, Wallet, Notifications.

## Code Style

### Comments

Avoid comments. Code should be self-explanatory through clear naming and small, focused functions. Do not add inline comments, section dividers, TODO comments, or doc comments unless the logic is genuinely non-obvious (e.g., a workaround for a platform bug or a complex algorithm). Never add comments that restate what the code already says.

### Naming

- Files: `snake_case.dart` — suffix by type: `*_bloc.dart`, `*_event.dart`, `*_state.dart`, `*_screen.dart`, `*_widget.dart`, `*_service.dart`, `*_repository.dart`.
- Classes: `PascalCase`. BLoCs: `FeedBloc`, Events: `FeedInitialized`, States: `FeedLoaded`.
- Variables and functions: `camelCase`.
- Private members: prefix with `_`.
- Constants: `camelCase` (Dart convention).

### Imports

- Use relative imports within the project.
- Group imports: Dart SDK → Flutter → packages → project-local.

### Async

- Use the project's `Result<T>` sealed class (`Success<T>`, `Error<T>`) from `lib/core/base/` for operation outcomes instead of throwing exceptions from repositories and services.
- Use `fold`, `map`, `flatMap` on `Result<T>` rather than manual `if (result.isSuccess)` checks when practical.

### Error Handling

- Catch exceptions at the repository/service boundary and convert them into `Result.error(...)`.
- BLoCs should emit error states, never throw.

### General

- Prefer `const` constructors wherever possible.
- Use `super.parameters` (enabled in analysis_options).
- One public class per file.
- Keep widgets small and composable; extract reusable widgets into `lib/ui/widgets/`.
- Use `Equatable` for all events, states, and entities.

## Localization

- ARB-based localization in `lib/l10n/`. Template is `app_en.arb`.
- Supported locales: en, tr, de.
- Access strings via `AppLocalizations.of(context)`. Never hardcode user-facing strings.

## File Organization

When adding a new feature:

1. Create entity in `lib/domain/entities/` if needed.
2. Create repository interface + impl in `lib/data/repositories/`.
3. Create BLoC with event/state files in `lib/presentation/blocs/<feature>/`.
4. Register in the appropriate DI module.
5. Create screen in `lib/ui/screens/<feature>/` and widgets in `lib/ui/widgets/<feature>/`.
6. Add route in `lib/core/router/`.

## Linting

- Follows `package:flutter_lints/flutter.yaml`.
- `bloc_lint` is enabled — follow its rules for BLoC structure.
- Fix all lint warnings before considering work complete.

## Generated Files — Do Not Edit

- `lib/src/rust/**` (flutter_rust_bridge output)
- `*.g.dart`, `*.freezed.dart` (if any build_runner output)
- `l10n/app_localizations*.dart`
