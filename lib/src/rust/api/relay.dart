// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `db_path_state`, `get_client_pub`, `get_client`, `open_or_recreate_lmdb`, `sanitize_lmdb_dir`, `state`, `try_open_lmdb`, `user_relays_state`, `wipe_db_directory`

Future<void> initClient(
        {required List<String> relayUrls,
        String? privateKeyHex,
        String? dbPath}) =>
    RustLib.instance.api.crateApiRelayInitClient(
        relayUrls: relayUrls, privateKeyHex: privateKeyHex, dbPath: dbPath);

Future<void> connectRelays() =>
    RustLib.instance.api.crateApiRelayConnectRelays();

Future<void> disconnectRelays() =>
    RustLib.instance.api.crateApiRelayDisconnectRelays();

Future<void> updateSigner({required String privateKeyHex}) =>
    RustLib.instance.api
        .crateApiRelayUpdateSigner(privateKeyHex: privateKeyHex);

Future<bool> isClientInitialized() =>
    RustLib.instance.api.crateApiRelayIsClientInitialized();

Future<bool> addRelay({required String url}) =>
    RustLib.instance.api.crateApiRelayAddRelay(url: url);

Future<bool> addRelayWithFlags(
        {required String url, required bool read, required bool write}) =>
    RustLib.instance.api
        .crateApiRelayAddRelayWithFlags(url: url, read: read, write: write);

Future<void> removeRelay({required String url}) =>
    RustLib.instance.api.crateApiRelayRemoveRelay(url: url);

Future<List<String>> getRelayList() =>
    RustLib.instance.api.crateApiRelayGetRelayList();

Future<int> getConnectedRelayCount() =>
    RustLib.instance.api.crateApiRelayGetConnectedRelayCount();

Future<String> getRelayStatus() =>
    RustLib.instance.api.crateApiRelayGetRelayStatus();

Future<String> discoverAndConnectOutboxRelays(
        {required List<String> pubkeysHex}) =>
    RustLib.instance.api
        .crateApiRelayDiscoverAndConnectOutboxRelays(pubkeysHex: pubkeysHex);

Future<String> syncEvents({required String filterJson}) =>
    RustLib.instance.api.crateApiRelaySyncEvents(filterJson: filterJson);

Future<String> fetchEvents(
        {required String filterJson, required int timeoutSecs}) =>
    RustLib.instance.api.crateApiRelayFetchEvents(
        filterJson: filterJson, timeoutSecs: timeoutSecs);

Future<String> fetchCountsFromRelays(
        {required List<String> noteIds, String? userPubkeyHex}) =>
    RustLib.instance.api.crateApiRelayFetchCountsFromRelays(
        noteIds: noteIds, userPubkeyHex: userPubkeyHex);

Future<String?> fetchEventById(
        {required String eventId, required int timeoutSecs}) =>
    RustLib.instance.api.crateApiRelayFetchEventById(
        eventId: eventId, timeoutSecs: timeoutSecs);

Future<String> sendEvent({required String eventJson}) =>
    RustLib.instance.api.crateApiRelaySendEvent(eventJson: eventJson);

Future<String> sendEventTo(
        {required String eventJson, required List<String> relayUrls}) =>
    RustLib.instance.api
        .crateApiRelaySendEventTo(eventJson: eventJson, relayUrls: relayUrls);

Future<String> broadcastEvents(
        {required String eventsJson, List<String>? relayUrls}) =>
    RustLib.instance.api.crateApiRelayBroadcastEvents(
        eventsJson: eventsJson, relayUrls: relayUrls);

Future<String> requestToVanish(
        {required List<String> relayUrls, required String reason}) =>
    RustLib.instance.api
        .crateApiRelayRequestToVanish(relayUrls: relayUrls, reason: reason);

Future<String> deleteEvents(
        {required List<String> eventIds, required String reason}) =>
    RustLib.instance.api
        .crateApiRelayDeleteEvents(eventIds: eventIds, reason: reason);

Stream<String> subscribeToEvents({required String filterJson}) =>
    RustLib.instance.api.crateApiRelaySubscribeToEvents(filterJson: filterJson);

Future<BigInt> getDatabaseSizeMb() =>
    RustLib.instance.api.crateApiRelayGetDatabaseSizeMb();
